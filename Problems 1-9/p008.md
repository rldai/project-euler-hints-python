## [The Problem:](https://projecteuler.net/problem=8)

<p>The four adjacent digits in the $1000$-digit number that have the greatest product are $9 \times 9 \times 8 \times 9 = 5832$.</p>
<p class="monospace center">
73167176531330624919225119674426574742355349194934<br>
96983520312774506326239578318016984801869478851843<br>
85861560789112949495459501737958331952853208805511<br>
12540698747158523863050715693290963295227443043557<br>
66896648950445244523161731856403098711121722383113<br>
62229893423380308135336276614282806444486645238749<br>
30358907296290491560440772390713810515859307960866<br>
70172427121883998797908792274921901699720888093776<br>
65727333001053367881220235421809751254540594752243<br>
52584907711670556013604839586446706324415722155397<br>
53697817977846174064955149290862569321978468622482<br>
83972241375657056057490261407972968652414535100474<br>
82166370484403199890008895243450658541227588666881<br>
16427171479924442928230863465674813919123162824586<br>
17866458359124566529476545682848912883142607690042<br>
24219022671055626321111109370544217506941658960408<br>
07198403850962455444362981230987879927244284909188<br>
84580156166097919133875499200524063689912560717606<br>
05886116467109405077541002256983155200055935729725<br>
71636269561882670428252483600823257530420752963450<br></p>
<p>Find the thirteen adjacent digits in the $1000$-digit number that have the greatest product. What is the value of this product?</p>

## Brute Force Solution:

<details>
    <summary>
        How do I get started?
    </summary>
        As shown in the solution to Problem 4, converting an integer to a string is faster for extracting digits than trying to deal with the integer itself.<br><br>
        Then, how do you separate out 13 adjacent digits from this string?<br></br>
        Then, how do you extract each individual digit?
</details>

<details>
    <summary>
        I don't know the answers!
    </summary>
        The answer, in short, is slices and for loops. We will call each set of 13 adjacent digits a "slice."<br><br>
  First, use a loop where the range corresponds to the number of slices in a 1000 digit number. The answer is not <code>1000 / 13</code>.<br><br>
  In each loop use a slice like <code>adjacent_digits = big_number_string[i : adjacent_digits_length + i]</code>.<br><br> 
  Then, extract individual digits with a for loop like this:<br><br>
  <code>for digit in adjacent_digits:
        product = product * int(digit)</code><br><br>
  Finally, add a variable to store the highest product found so far. Update it when you find a higher product than it.
</details>

<details>
    <summary>
        Final Solution (The Author):
    </summary><code>big_number = 7316717...
big_number_string = str(big_number)
adjacent_digits_length = 13
#
highest_product = 0
for i in range(0, 1000 - adjacent_digits_length):
    adjacent_digits = big_number_string[i : adjacent_digits_length + i]
    product = 1
    for digit in adjacent_digits:
        product = product * int(digit)
    if product > highest_product:
        highest_product = product
print(highest_product)</code><br><br>
  Runtime: 0.002 seconds
</details>

## Nice Solution:

<details>
    <summary>
        But can I make it faster?
    </summary>
  Yes. Currently the code checks every single slice. There are some that can be skipped because without calculating their product, it is guarenteed they cannot be the highest. What are they?
  </details>

<details>
    <summary>
        I don't know the answer to that question.
    </summary>
Slices containing zeros will have their product equal zero.  
  </details>

<details>
    <summary>
        I need another hint.
    </summary>
Consider the <code>for digit in adjacent_digits:</code> statement. Try adding a statement for if the digit is zero.
</details>

<details>
    <summary>
        What is that in code form?
    </summary>
  <code>    for digit in adjacent_digits:
        product = product * int(digit)
        if product == 0:
            break</code><br><br>
  There are some inefficiencies with this. If a slice has a 0, the ones surrounding it also have a 0. It would be nice to skip multiple slices at once to the first slice that doesn't have that zero in it. This canot be done with the break function. There are at least two other ways to doing it. Try to find them. 
</details>

<details>
    <summary>
        I can't find them!
    </summary>
  The first way is to use a while loop. The second way is to use <code>iter()</code>, as described by <cite
      ><a href="https://stackoverflow.com/questions/22295901/skip-multiple-iterations-in-loop"
        >Martjin Pieters on Stack Overflow.</a></cite>
</details>

<details>
    <summary>
        What's that in code form?
    </summary>
    Here is the first way:<br><code>big_number = 7316717...
big_number_string = str(big_number)
adjacent_digits_length = 13
#
highest_product = 0
i = 0
while i < 1000 - adjacent_digits_length:
    adjacent_digits = big_number_string[i : adjacent_digits_length + i]
    product = 1
    for digit in adjacent_digits:
        product = product * int(digit)
        if product == 0:
            skip_number = adjacent_digits.index("0")
            i += skip_number
            break
    if product > highest_product:
        highest_product = product
    i += 1
print(highest_product)</code><br><br>
  Runtime: 0.001 seconds
</details>

<details>
    <summary>
        But can I make it EVEN BETTER??
    </summary>
  Yes. The improved code still recalculates the product for each string starting from 1. However, of out of 13 digits of a new slice are shared with a previous slice. Most of the work is already done. How can you change the product of a previous slice to turn it into a new slice? 
</details>

<details>
    <summary>
        I don't know the answer.
    </summary>
  Divide the first digit in the previous slice and multiply the new digit from the new slice. Then, you only have to calculate the product of the first 13 digits. The rest of them can be found just by modifying the first and last digit. This idea of only changing the fist and last element is a "sliding window technique." <br><br>
  The difficulty here is to find a way to implement both time-saving measures into the same code. Below is code that implements the sliding window method without skipping zeros. Where the function would multiply or divide by zero, it uses 0.0001 instead.
</details>

<details>
    <summary>
        How do I do both?
    </summary><code>big_number = 7316717...
big_number_string = str(big_number)
adjacent_digits_length = 13
#
initial_slice = big_number_string[0: adjacent_digits_length]
product = 1
for digit in initial_slice:
    if digit == "0":
        product = product * 0.0001
    else:
        product = product * int(digit)
highest_product = product
#
for i in range(0, 1000 - adjacent_digits_length):
    if big_number_string[i] == "0":
        product = product / 0.0001
    else:
        product = product / int(big_number_string[i])
    if big_number_string[i + adjacent_digits_length] == "0":
        product = product * 0.0001
    else:
        product = product * int(big_number_string[i + adjacent_digits_length])
    if product > highest_product:
        highest_product = product
#
print(int(highest_product + 0.5))</code><br><br>
  Runtime: 0.0005 seconds<br><br>
  The trouble is that when skipping because of a zero, the sliding window doesn't work anymore. A clever solution, one I didn't think of myself, can be attributed to apruitt0321 on the Project Euler forum. Split the big number into sections separated by the zeros. Then, call the sliding window funciton for each of these substrings.
</details>

<details>
    <summary>
        Final Solution (The Author and apruitt0321 in Project Euler forum):
          </summary>
      <code>#big_number = 7316717...
big_number_string = str(big_number)
adjacent_digits_length = 13
#
def sliding_window(string):
    global adjacent_digits_length
    initial_slice = string[0: adjacent_digits_length]
    product = 1
    for digit in initial_slice:
        if digit == "0":
            product = product * 0.0001
        else:
            product = product * int(digit)
    highest_product_in_string = product
#
    for i in range(0, len(string) - adjacent_digits_length):
        if string[i] == "0":
            product = product / 0.0001
        else:
            product = product / int(string[i])
        if string[i + adjacent_digits_length] == "0":
            product = product * 0.0001
        else:
            product = product * int(string[i + adjacent_digits_length])
        highest_product_in_string = max(highest_product_in_string, product)
    return highest_product_in_string
#
list_of_substrings = big_number_string.split("0")
highest_product = 0
for substring in list_of_substrings:
    if len(substring) >= adjacent_digits_length:
        highest_product = max(highest_product, sliding_window(substring))
#
print(int(highest_product + 0.5))</code><br><br>
  Runtime: 0.0002 seconds
</details>
