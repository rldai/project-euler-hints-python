## [The Problem:](https://projecteuler.net/problem=7)

<p>By listing the first six prime numbers: $2, 3, 5, 7, 11$, and $13$, we can see that the 6th prime is $13$.</p>
<p>What is the 10001st prime number?</p>

<details>
    <summary>
        How do I get started?
    </summary>
        The problem can a modified version of the function in Problem 3 or the "Primes under x generator," which is in the "Tools" folder of the depository. The former is solution 1 and the latter is solution 2. The latter function is faster, but not "nicer" because it requires some extra knowledge that's extremely difficult to derive independently, unlike other nice solutions.
</details>

## Solution 1:

<details>
    <summary>
        What exactly do I have to do to make this work?
    </summary>
        The following is the relevant section of code from Problem 3:<br>
        <code>factor_cap = int(math.sqrt(n))
while n > 1 and factor <= factor_cap:
    if n % factor == 0:
        greatest_factor = factor
        while n % factor == 0:
            n = n // factor
        factor_cap = int(math.sqrt(n))
    factor = factor + 2</code><br><br>
    You can convert this into an "is_prime(n)" function that takes in n and returns True or False. For the is_prime function, you don't have to divide n by a factor. Instead, you return False, since n is divisible by the factor and therefore not prime. Declare what the factor is. Add in where the function must return True or False.<br><br>
    For the rest of the code, use a "counter" variable and a "number" variable. Use a while loop when the counter is less than 10001, and check if the number is prime. If the numebr is prime, increment the counter. Regardless, increment the number.
</details>

<details>
    <summary>
        Final Solution (hk in Project Euler Overview):
    </summary><code>import math
def is_prime(n):
    if n % 3 == 0 or n % 5 == 0:
        return False
    factor_cap = int(math.sqrt(n))
    factor = 5
    while factor <= factor_cap:
        if n % factor == 0:
            return False
        factor = factor + 2
    return True
#
# Skipping 2, 3, and 5
i = 3
n = 7
ith_prime = 3
while i < 10001:
    if is_prime(n):
        i += 1
        ith_prime = n
    n += 2
print(ith_prime)</code><br><br>
    Runtime: 0.09 seconds<br>
    Runtime when finding the 100001st prime: 2.6 seconds
</details>

## Solution 2 (The Author):

<details>
    <summary>
        How do I find an upper bound?
    </summary>
        The code in "Primes under x generator" needs an upper_limit to run. Then, it produces a list of primes. To find the 10001st prime, you just need to find primes[10001 - 1]. The problem here is how to find an upper limit in the first place. <br><br>
    An approximation of the nth prime number was found as a result of the prime number theorem. The prime number theorem states that the number of prime numbers under N is approximately N / ln(N). Consequently, the nth prime number can be approximated as n * ln(n). This is an approximation, not an upper bound, so some slack should be added to guarantee the the nth prime is below the upper limit.
</details>

<details>
    <summary>
        Final Solution (The Author):
    </summary>
        <code>import math
#
n = 1000001
upper_limit= int(n * math.log(n) * 1.5)
primes_set = {2, 3}
#
for i in range(5, upper_limit, 2):
    if i % 3 != 0:
        primes_set.add(i)
#
factor = 5
square_root_of_upper_limit = upper_limit**0.5
while factor <= square_root_of_upper_limit:
    multiples_of_factor = upper_limit // factor
    for i in range(3, multiples_of_factor + 1, 2):
        if i % 3 != 0:
            primes_set.discard(factor * i)
    factor += 2
    if factor % 3 == 0:
        factor = factor + 2
#
primes = sorted(list(primes_set))
print(primes[n - 1])</code><br><br>
    Runtime: 0.025 seconds<br>
    Runtime: 0.27 seconds<br><br>
    (AN: I picked the factor 1.5 arbitrarily.)
</details>
