## [The Problem:](https://projecteuler.net/problem=4)

<p>A palindromic number reads the same both ways. The largest palindrome made from the product of two $2$-digit numbers is $9009 = 91 \times 99$.</p>
<p>Find the largest palindrome made from the product of two $3$-digit numbers.</p>

## Brute Force Solution:

<details>
    <summary>
        How do I get started?
    </summary>
        First, how do you would you go through every pair of 3 digit numbers? <br><br>
        Then, how do you check if a number is a palindrome? There are a number of ways to do this using the mod operator, rounding operations like <code>int()</code> or <code>//</code>, and using <code>math.log10()</code>. Hint: the fastest way doesn't use any math!
</details>

<details>
    <summary>
        I don't know the answers.
    </summary>
        First, you can use nested for loops. Have one like <code>for x in range(100, 1000)</code> and one like <code>for y in range(100, 1000)</code>. Then, in the innermost for loop, you can calculate <code>z = x * y</code>. <br><br>
        Then, there are many, many, ways to check if something is a palindrome. A quick rundown, generally from worst to best ideas:<br><br>
        4. Using <code>int(math.log10)</code> to find how many digits long <code>z</code> is. A pro is that it makes the program flexible for if you want to find, say, the largest palindrome that's the product of 2 4-digit numbers. However, there is a much better way of counting digits (and you don't even have to know this information for the fastest programs). (Credit to myself in my first attempts at this problem. I did give up this idea fairly quickly, but it would techinically work with enough effort.)<br><br>
        3. Finding the rightmost digit and subtracting it from z, then the second rightmost, etc. Comparing the rightmost digit to the leftmost, then the second rightmost to the second leftmost, etc. (I would credit who did this idea, but I consider this a bad idea, and I don't want to draw negative attention to this person/idea.)<br><br>
        2. You can do something similar to the above idea, but you don't have to subtract! You can do <code>z // 10</code> and boom, the second rightmost digit becomes the rightmost digit. This is the idea in the Project Euler overview written by Lster. In the overview, there is another variable in addition to <code>z</code>, which they call <code>reversed</code>. When the digit is removed from <code>z</code>, it is added to <code>reversed</code>. Then, instead of comparing individual digits, it compares <code>z</code> and reversed. <br><br>
        1. CONVERTING TO A STRING! This is 3-4 times faster than the code in the Project Euler overview. You could use a for loop like this:<br><br>
    <code>for i in range(0, len(z_string) // 2): 
    if z_string[0 + i] != z_string[-1 - i]: 
        return False.</code><br><br>
    (If you do something like that, be sure to divide by 2 in the <code>range(0, len(z_string) // 2)</code> to avoid checking a pair of digits twice. You can also use a list splice like this: <br><br>
    <code>z_reversed = z_string[::-1]</code><br><br> (which I found to be slightly faster than the previous method).<br><br>
        The code for a program that uses <code>z_reversed = z_string[::-1]</code> is below: <br>
</details>

<details>
    <summary>
        Preliminary Solution (The Author):
    </summary>
        <code>lower_limit = 100
upper_limit = 1000
#
def is_palindrome(z):
    z_string = str(z)
    z_reversed = z_string[::-1]
    return z_string == z_reversed
#
highest_palindrome = 0
for x in range(lower_limit ,upper_limit):
    for y in range(lower_limit ,upper_limit):
        if is_palindrome(x * y):
            if x * y > highest_palindrome:
                highest_palindrome = x * y
#
print(highest_palindrome)</code>
  Runtime: 0.125 seconds<br>
Runtime for 4 digit numbers: 12 seconds
</details>

<details>
    <summary>
        But can we make it faster?
    </summary>
        There are a couple of small improvements before the breakthrough that defines the "nice" section. First, the current code checks every product twice. For example, it calculates the product when <code>x = 100</code> and <code>y = 200</code>, and also when <code>x = 200</code> and <code>y = 100</code>. How do you make it only check every pair of a and b once?<br><br>
        Then, the current code checks every single product to find the highest palindrome. If you started from the top, counting down instead of up, you would find the highest palindrome faster. However, how would you know when to stop checking? Do you know that the first palindrome found would be the highest?
</details>

<details>
    <summary>
        What are the answers?
    </summary>
        First, make it so y is only <code>in range(100, x + 1)</code>. Then, y is restricted to being less than or equal to x. In the above example, it would calculate the product when <code>x = 200</code> and <code>y = 100</code> but not when <code>x = 100</code> and <code>y = 200</code>. <br><br>
    Then, to make the for loop count down, you use <code>for x in range (999, 100, -1)</code> instead of <code>for x in range (100, 1000)</code>. Also, change <code>for y in range(100, x + 1)</code> to <code>for y in range(x, 100, -1)</code>. Since <code>y</code> is restricted to being less than <code>x</code>, the highest product in the for loop for <code>x</code> would be <code>x ** 2</code>. So, if <code>x ** 2</code> is less than the current highest palindrome, the loop can stop early and the highest palindrome can be returned. Similarly, since <y> also counts down, if <code>x * y</code> is less than the highest palindrome found, the loop can <code>break</code> so the next value of x can be checked. Similarly, if <code>x * y</code> is a palindrome, the loop can <code>break</code>.
</details>

<details>
    <summary>
        Final Solution (Lster in Project Euler Overview):
    </summary><code>lower_limit = 100
upper_limit = 1000
#
def is_palindrome(z):
    z_string = str(z)
    z_reversed = z_string[::-1]
    return z_string == z_reversed
#
highest_palindrome = 0
for x in range(upper_limit, lower_limit, -1):
    if x ** 2 < highest_palindrome:
        break
    for y in range(x, lower_limit, -1):
        product = x * y
        if product < highest_palindrome:
            break
        elif is_palindrome(product):
            highest_palindrome = x * y
            break
#
print(highest_palindrome)</code><br><br>
        Runtime: 0.0025 seconds<br>
        Runtime for 4 digit numbers: 0.004 seconds
</details>

## Nice Solution 

<details>
    <summary>
        But can we make it faster?
    </summary>
        There is a property of even digit palindromes that can be found. There will be hints for how to find this property, but first, some justification for only looking for even digit palindromes. A 3 digit integer times a 3 digit integer is between 10000 (5 digits) and 998001 (6 digits). This can be found by squaring the lowest 3 digit number (100) and the highest (999). So, it seems likely the highest palindrome will be 6 digits long. If you realize <code>111111 = 143 * 777</code>, then you know the highest palindrome will be at least 111111, so it will be 6 digits. if you don't relaize this, then this is just a lucky guess. <br><br>
    Changing the code to only find even digit palindromes will make it so you cannot find the highest palindrome that is the product of, for example, two numbers less than 300. It will still be good for finding palindromes that are the product of <code>x</code> digit numbers, since the number of digits in <code>(10 ** x - 1) ** 2</code> will always be even if <code>x</code> is a positive natural number. 
</details>

<details>
    <summary>
        What is the property?
    </summary>
        Realize 6 digit palindromes are of the form abccba. This means a palindrome is equal to <code>100000 * a + 10000 * b + 1000 * c + 100 * c + 10 * b + a</code>. Simplifying, this is equal to <code>100001 * a + 10010 * b + 1100 * c</code>.
</details>

<details>
    <summary>
        I can't find the property.
    </summary>
        The expression is divisible by 11. This can be spotted quickly with a divisibility test often taught in grade school: Add together the digits in the odd places (1st, 3rd, 5th...). Then, add the digits int he even places (2nd, 4th, 6th...). Subtract these two sums. If the difference is a multiple of 11 (including 0), the number is a multiple of 11. Clearly, the terms in <code>100001 * a + 10010 * b + 1100 * c</code> are divisible by 11 according to this rule.<br><br>
        This rule can be proven, but will be taken for granted in this walkthrough. <br><br>
    To change our code to make sure <code>x</code> or <code>y</code> is a multiple of 11 is a little tricky. You do not know which variable, <code>x</code> or <code>y</code>, will be divisible by 11.
</details>

<details>
    <summary>
        How do I change the code to incorporate this new information?
    </summary>
        First, if <code>x</code> is a multiple of 11, nothing has to change. If <code>x</code> is not a multiple of 11, then <code>y</code> must be a multiple of 11. This can be done by having the starting value of <code>y</code> be a multiple 11, then incrementing down by 11. 
</details>

<details>
    <summary>
        Final Solution (Lster in Project Euler Overview):
    </summary><code>lower_limit = 100
upper_limit = 1000
#
def is_palindrome(z):
    z_string = str(z)
    z_reversed = z_string[::-1]
    return z_string == z_reversed
#
highest_palindrome = 0
x = upper_limit - 1
for x in range(upper_limit, lower_limit, -1):
    if x ** 2 < highest_palindrome:
        break
    if x % 11 == 0:
        # Stands for delta y, or change in y.
        dy = -1
        y_upper_limit = upper_limit - 1
    else:
        dy = -11
        # Makes y start at the highest multiple of 11 less than the upper_limit
        y_upper_limit = upper_limit // 11 * 11
    for y in range(y_upper_limit, lower_limit, dy):
        product = x * y
        if product < highest_palindrome:
            break
        elif is_palindrome(product):
            highest_palindrome = x * y
#
print(highest_palindrome)</code>
</details>
