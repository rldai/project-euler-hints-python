## [The Problem:](https://projecteuler.net/problem=4)

<p>A palindromic number reads the same both ways. The largest palindrome made from the product of two $2$-digit numbers is $9009 = 91 \times 99$.</p>
<p>Find the largest palindrome made from the product of two $3$-digit numbers.</p>

## Brute Force Solution:

<details>
    <summary>
        How do I get started?
    </summary>
        First, how do you would you go through every pair of 3 digit numbers? <br><br>
        Then, how do you check if a number is a palindrome? There are a number of ways to do this using the mod operator, rounding operations like int() or //, and using math.log10(). Hint: the fastest way doesn't use any math!
</details>

<details>
    <summary>
        I don't know the answers.
    </summary>
        First, you can use nested for loops. Have one for x in range(100, 1000) and one for y in range(100, 1000). Then, in the innermost for loop, you can calculate z = x * y. <br><br>
        Then, there are many, many, ways to check if something is a palindrome. A quick rundown, generally from worst to best ideas:<br><br>
        4. Using int(math.log10) to find how many digits long z is. A pro is that it makes the program flexible for if you want to find, say, the largest palindrome that's the product of 2 4-digit numbers. However, there is a much better way of counting digits (and you don't even have to know this information for the fastest programs). (Credit to myself in my first attempts at this problem. I did give up this idea fairly quickly, but it would techinically work with enough effort.)<br><br>
        3. Finding the rightmost digit and subtracting it from z, then the second rightmost, etc. Comparing the rightmost digit to the leftmost, then the second rightmost to the second leftmost, etc. (I would credit who did this idea, but I consider this a bad idea, and I don't want to draw negative attention to this person/idea.)<br><br>
        2. You can do something similar to the above idea, but you don't have to subtract! You can do z // 10 and boom, the second rightmost digit becomes the rightmost digit. This is the idea in the Project Euler overview written by Lster. In the overview, there is another variable in addition to z, which they call reversed. When the digit is removed from z, it is added to reversed. Then, instead of comparing individual digits, it compares z and reversed. <br><br>
        1. CONVERTING TO A STRING! This is 3-4 times faster than the code in the Project Euler overview. You could use a for loop where for i in range(0, len(z_string) // 2): if z_string[0 + i] != z_string[-1 - i]: return False. (If you do something like that, be sure to divide by 2 in the range(0, len(z_string) // 2) to avoid checking a pair of digits twice. You can also use a list splice like z_reversed = z_string[::-1] (which I found to be slightly faster than the previous method).<br><br>
        The code for a program that uses z_reversed = z_string[::-1] is below: <br>
</details>

<details>
    <summary>
        Final Solution (The Author):
    </summary>
        <code>def is_palindrome(z):
    z_string = str(z)
    z_reversed = z_string[::-1]
    return z_string == z_reversed
#
highest_palindrome = 0
for x in range(100 ,1000):
    for y in range(100 ,1000):
        if is_palindrome(x * y):
            if x * y > highest_palindrome:
                highest_palindrome = x * y
#
print(highest_palindrome)</code><br><br>
  Runtime: 0.125 seconds
</details>

## Nice Solution coming soon!
