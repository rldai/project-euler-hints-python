## [The Problem:](https://projecteuler.net/problem=3)

<p>The prime factors of $13195$ are $5, 7, 13$ and $29$.</p>
<p>What is the largest prime factor of the number $600851475143$?</p>

## Brute Force Solution:
<details>
    <summary>
        How do I get started?
    </summary>
        Try going through all the possible factors least to greatest. Testing every single number less than <code>600851475143</code> would be too slow, so how do you make that faster?
</details>

<details>
    <summary>
        I need another hint!
    </summary>
       Let <code>n = 600851475143</code>. As you check each factor, divide <code>n</code> by that factor. Eventually you will reach 1. <br>
</details>

<details>
    <summary>
        Final Solution (hk on Project Euler Overview):
    </summary>
       <code>n = 600851475143
factor = 2
greatest_factor = 1
#
while n > 1:
    if n % factor == 0:
        while n % factor == 0:
            greatest_factor = factor
            n = n // factor
    factor += 1
#
print(greatest_factor)</code><br><br>
    Runtime: 0.001 seconds <br>
    Runtime if <code>n = 16777186 = 2 * 838859</code>(a prime number): 0.65 seconds <br>
</details>

## Nice Solution:
<details>
    <summary>
        How can we make this more efficient?
    </summary>
        There are two improvements to make. First, you do not have to check up until you reach n. There is an earlier stopping point where <code>n = 1</code> if <code>n</code> is composite. If <code>n</code> is prime, <code>n</code> will be greater than 1, but after the stopping point, you can check <code>if n > 0</code>. Then, you know the greatest prime factor of <code>n</code> would be <code>n</code>.<br><br>
    Second, you dont have to check every number. You can skip some. 
</details>

<details>
    <summary>
        I need more hints!
    </summary>
        First, imagine if <code>n = 2 * some_large_prime</code>. Then, the program would check every factor until that large prime. To prevent that, realize you only have to check factors up until the square root of <code>n</code>. If <code>n</code> is composite, it will have a factor less than or equal to its square root. If <code>n</code> is prime, the program will quit early and save time. <br><br>
    Second, you only have to check odd factors and handle 2 as a separate case. This effectively cuts the runtime in half.
</details>

<details>
    <summary>
        Final Solution:
    </summary>
        <code>n = 600851475143
#
if n % 2 == 0:
    greatest_factor = 2
    while n % 2 == 0:
        n = n // 2
else:
    greatest_factor = 1
factor = 3
#
factor_cap = int(math.sqrt(n))
while n > 1 and factor <= factor_cap:
    if n % factor == 0:
        greatest_factor = factor
        while n % factor == 0:
            n = n // factor
        factor_cap = int(math.sqrt(n))
    factor = factor + 2
#
if n == 1:
    print(greatest_factor)
else:
    print(n)</code><br><br>
    Runtime: 0.001 seconds <br>
    Runtime if <code>n = 16777186</code>: 0.001 seconds <br><br>
    (AN: In first attempt, I used my primes under x generator, which can be found in the Tools folder. This had a slower runtime than the solution from Project Euler.)
</details>
